```
package algo;

import java.util.*;

class Solution {
    public String solution(int n, int k, String[] cmd) {
        HashMap<Integer, Boolean> maps = new HashMap<>();
        int currentIndex = k;
        for (int i = 0; i < n; i++) {
            maps.put(i, true);
        }

        Stack<Integer> lastDeletedIndex = new Stack<>();
        for (int i = 0; i < cmd.length; i++) {
            String[] split = cmd[i].split(" ");
            if (split.length == 1) {
                // C
                if (split[0].equals("C")) {
                    int flag = 0;
                    int nextIndex = 0;
                    for (int j = currentIndex + 1; j < maps.size(); j++) {
                        if (maps.get(j) == true) {
                            flag = 1;
                            nextIndex = j;
                            break;
                        }
                    }
                    if (flag == 1) {
                        // 아래 더 행이 있으니 지우고 아래를 선택한다
                        maps.put(currentIndex, false);
                        lastDeletedIndex.push(currentIndex);
                        currentIndex = nextIndex;
                    } else {
                        maps.put(currentIndex, false);
                        lastDeletedIndex.push(currentIndex);
                        for (int j = currentIndex - 1; j >= 0; j--) {
                            if (maps.get(j) == true) {
                                currentIndex = j;
                                break;
                            }
                        }
                    }
                }
                // Z
                if (split[0].equals("Z")) {
                    Integer pop = lastDeletedIndex.pop();
                    maps.put(pop, true);
                }

            } else {
                // U
                String command = split[0];
                int target = Integer.parseInt(split[1]);

                if (command.equals("D")) {
                    for (int j = currentIndex+1; j < maps.size(); j++) {
                        if (maps.get(j) == true) {
                            target--;
                        }
                        if (target == 0) {
                            currentIndex = j;
                            break;
                        }
                    }
                }
                // D
                if (command.equals("U")) {
                    for (int j = currentIndex-1; j >=0; j--) {
                        if (maps.get(j) == true) {
                            target--;
                        }
                        if (target == 0) {
                            currentIndex = j;
                            break;
                        }
                    }
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < maps.size(); i++) {
            if (maps.get(i) == true) {
                sb.append('O');
            } else {
                sb.append('X');
            }
        }


        return sb.toString();
    }
}
```

```
효율성 일부 실패
연결리스트 2개를 활용해서 풀어보기
```
